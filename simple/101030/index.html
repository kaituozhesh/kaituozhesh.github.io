<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
	<meta name="keywords" content="JUC,AQS,AbstractQueueSynchronizer,独占式,共享式,源码分析">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://www.ityizhan.net">
  <title>03.JUC核心篇：AQS(AbstractQueueSynchronizer) | 程序驿站|一个专注于分享的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="全网最全的AQS源码分析，从数据结构到同步容器的使用技巧，并逐行分析核心源码，及最后的面试总结">
<meta property="og:type" content="article">
<meta property="og:title" content="03.JUC核心篇：AQS(AbstractQueueSynchronizer)">
<meta property="og:url" content="http://www.ityizhan.net/simple/101030/index.html">
<meta property="og:site_name" content="程序驿站|一个专注于分享的博客">
<meta property="og:description" content="全网最全的AQS源码分析，从数据结构到同步容器的使用技巧，并逐行分析核心源码，及最后的面试总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://resources.ityizhan.net/1UXmasMw3Dpe9Z5.png">
<meta property="article:published_time" content="2021-04-02T05:31:39.000Z">
<meta property="article:modified_time" content="2021-05-24T08:17:52.696Z">
<meta property="article:author" content="程序驿站">
<meta property="article:tag" content="源码分析">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://resources.ityizhan.net/1UXmasMw3Dpe9Z5.png">
  
    <link rel="alternative" href="/atom.xml" title="程序驿站|一个专注于分享的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.0cf68a.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

  
<script>
  (function () {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"><a href="/">程序驿站</a></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/img/logo.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"></h1>
		</hgroup>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/simple">前置技术</a></li>
	        
				<li><a href="/">技术提升</a></li>
	        
				<li><a href="/">核心技术</a></li>
	        
				<li><a href="/">分布式架构</a></li>
	        
				<li><a href="/">微服务架构</a></li>
	        
				<li><a href="/">大数据与云计算</a></li>
	        
				<li><a href="/">服务管理</a></li>
	        
				<li><a href="/code">源码分析</a></li>
	        
				<li><a href="/">番外篇</a></li>
	        
			</ul>
		</nav>
		<nav>
			<a>总文章数 18</a>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="https://github.com/kaituozhesh" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
		        
			</div>
		</nav>
		<nav class="header-ewm">
			<img src="/img/wxgzh.jpg" />
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" /*style="background: #4d4d4d*/"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/img/logo.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">程序驿站</h1>
			</hgroup>
			
			
			
				
			
				
			
				
			
				
			
				
			
				
			
				
			
				
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/kaituozhesh" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 70%">
				
				
					<li style="width: 10%"><a href="/">主页</a></li>
		        
					<li style="width: 10%"><a href="/simple">前置技术</a></li>
		        
					<li style="width: 10%"><a href="/">技术提升</a></li>
		        
					<li style="width: 10%"><a href="/">核心技术</a></li>
		        
					<li style="width: 10%"><a href="/">分布式架构</a></li>
		        
					<li style="width: 10%"><a href="/">微服务架构</a></li>
		        
					<li style="width: 10%"><a href="/">大数据与云计算</a></li>
		        
					<li style="width: 10%"><a href="/">服务管理</a></li>
		        
					<li style="width: 10%"><a href="/code">源码分析</a></li>
		        
					<li style="width: 10%"><a href="/">番外篇</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            <article id="post-code/JUC/03.JUC核心篇：AQS(AbstractQueueSynchronizer)" class="article article-type-post " itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      03.JUC核心篇：AQS(AbstractQueueSynchronizer)
    </h1>
  

	<!--显示阅读次数-->
	
  	<br/>
  	<a class="cloud-tie-join-count" href="javascript:void(0);" style="color:gray;font-size:14px;">
  	<span class="icon-sort"></span>
  	<span id="busuanzi_container_page_pv" style="color:#ef7522;font-size:14px;">
            阅读数: <span id="busuanzi_value_page_pv"></span>次 &nbsp;&nbsp;
  	</span>
  	</a>
  	<div align="center" class="post-count">
	    字数：10.5k字 | 预计阅读时长：43分钟
	</div>
	
	<!--显示阅读次数完毕-->
	
        <a href="/simple/101030/" class="archive-article-date">
  	<time datetime="2021-04-02T05:31:39.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-04-02</time>
</a>
      	
      </header>
    

    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>应付面试可直接跳转到文章结尾处的总结</p>
</blockquote>
<span id="more"></span>
<h1 id="AQS（AbstractQueueSynchronizer）"><a href="#AQS（AbstractQueueSynchronizer）" class="headerlink" title="AQS（AbstractQueueSynchronizer）"></a>AQS（AbstractQueueSynchronizer）</h1><p>在锁框架中，AbstractQueueSynchronizer抽象类可以毫不夸张的说，占据着核心地位，它提供了一个基于FIFO队列，可以用于构建锁或者其他相关装置的基础框架。</p>
<p>AbstractQueueSynchronizer会把所有的请求线程构成一个CLH队列，当一个线程执行完毕（lock.unlock）时会激活自己的后继节点，但正在执行的线程并不在队列中，而那些等待执行的线程全部处于阻塞状态。</p>
<p>注：大多数JUC包下的并发工具类都是利用AbstractQueuedSynchronizer同步器来委托实现的，它是用来构建锁或者其他同步组件的基础框架。想要弄明白并发原理，搞明白AQS的实现机制很重要。</p>
<p>AQS主要实现了独占式和共享式</p>
<p><font color=#FF6600><strong>独占式：</strong></font>同步状态在0与1之间切换，同一时刻只有一个线程获取锁进行操作，其他线程挂起，ReentrantLock就是一个经典的独占式锁。</p>
<p><font color=#FF6600><strong>共享式：</strong></font>PROPAGATE的数值大于0，可以使同一时刻有多个线程获取锁，如果PROPAGATE小于0，则就变成了共享式模式，可以参照Semphore。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><img src="http://resources.ityizhan.net/1UXmasMw3Dpe9Z5.png" alt="AQS数据结构"></p>
<p>AbstractQueuedSynchronizer类底层的数据结构使用的是 <code>双向链表 + state(锁状态) + 底层CAS操作</code>。</p>
<p><font color=#FF6600><strong>Sync queue（同步队列）：</strong></font>是一个双向链表，包括head节点和tail节点，head节点主要做后续的调度。</p>
<p><font color=#FF6600><strong>Condition queue（条件队列）：</strong></font>这不是必须的，它是一个单向链表，只有当使用Condition时，才会存在此单向链表。并且可能会有多个。</p>
<p>概念：</p>
<ul>
<li>AQS使用了一个int类型的state成员变量表示同步状态，通过Node类型的head和tail头尾节点所确定的FIFO队列来完成资源获取线程的排队工作。</li>
<li>当一个线程成功的获取了同步状态，其他线程将无法获取到同步状态，没有成功获取同步状态的线程会成为节点加入该队列的尾部，为保证线程安全，使用<code>compareAndSetTail(Node expect, Node update)</code>方法原子更新在尾部插入等待节点。</li>
<li>头节点是获取同步状态成功的节点，头节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。<ul>
<li>获取同步状态成功的线程才能设置头节点，且只有一个线程能获取到同步状态，不存在线程安全问题，所以不用CAS来设置节点。</li>
</ul>
</li>
</ul>
<h2 id="同步容器AQS的基本用法"><a href="#同步容器AQS的基本用法" class="headerlink" title="同步容器AQS的基本用法"></a>同步容器AQS的基本用法</h2><p>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的三个方法<code>getState()</code>、<code>setState(int newState)</code>、<code>compareAndSetState(int expect, int update)</code> 来进行操作，因为它们能够保证状态的改变是安全的。</p>
<p>子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式的获取同步状态，这样就可以方便实现不同类型的同步组件。</p>
<h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><p>同步器的设计是基于模板方法的，也就是说，使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。而重写同步器指定的方法时，需要使用同步器提供的如下三个方法来访问或修改同步状态。</p>
<ul>
<li><code>getState()</code> ： 获取当前同步状态。</li>
<li><code>setState(int newState)</code> ： 设置当前同步状态。</li>
<li><code>compareAndSetState(int expect, int update)</code> ： 使用CAS设置当前状态，该方法能保证状态设置的原子性。</li>
</ul>
<h3 id="AQS可重写的方法"><a href="#AQS可重写的方法" class="headerlink" title="AQS可重写的方法"></a>AQS可重写的方法</h3><ul>
<li>boolean tryAcquire(int)：独占式获取同步状态，实现此方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态。</li>
<li>boolean tryRelease(int)：独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态。</li>
<li>boolean isHeldExclusively()：当前同步器是否在独占模式下被线程占用，一般此方法表示是否被当前线程所独占。</li>
<li>int tryAcquireShared(int)：共享式获取同步状态。</li>
<li>boolean tryReleaseShared(int)：共享式释放同步状态。</li>
</ul>
<h3 id="AQS中的模板方法"><a href="#AQS中的模板方法" class="headerlink" title="AQS中的模板方法"></a>AQS中的模板方法</h3><p>以下的模板方法的内部都会调用上面说的5个可被重写的方法，而自定义同步组件在实现一些同步功能时一般会使用委托的方法调用AQS的这些模板方法，而不是直接调用上面AQS的那5个可重写的方法，当然也有例外，比如：ReentrantLock的tryLock()方法就是直接调用 <code>boolean tryAcquire(int)</code></p>
<ul>
<li>void acquire(int)：独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用重写的tryAcquire(int)方法。</li>
<li>void acquireInterruptibly(int)：与acquire(int arg)相同，但是该方法响应中断，当前线程未获取到同步状态而进入同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException并返回。</li>
<li>boolean tryAcquireNanos(int ,long)：在acquireInterruptibly(int arg)基础上增加了超时限制，如果当前线程在超时时间内没有获取到同步状态，那么将会返回false,如果获取到了返回true。</li>
<li>boolean release(int)：独占式的释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒。</li>
<li>void acquireShared(int)：共享式的获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式获取的主要区别是在同一时刻可以由多个线程获取到同步状态。</li>
<li>void acquireSharedInterruptibly(int)：与acquireShared(int)相同，该方法响应中断。</li>
<li>boolean tryAcquireSharedNanos(int, long)：在acquireSharedInterruptibly(int)基础上增加了超时限制。</li>
<li>boolean releaseShared(int)：共享式的释放同步状态。</li>
</ul>
<h2 id="源码示例"><a href="#源码示例" class="headerlink" title="源码示例"></a>源码示例</h2><h3 id="AQS类中的排他锁示例"><a href="#AQS类中的排他锁示例" class="headerlink" title="AQS类中的排他锁示例"></a>AQS类中的排他锁示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果state是0，表明锁没有被其他线程抢占，可以获取锁</span></span><br><span class="line"><span class="comment">     * 如果state是1，表明锁被某个线程抢占了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 锁的状态，即是否被某个抢占了</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果state是0，尝试抢锁</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// cas原子操作地修改state的值，修改成功，表示抢锁成功</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">               	<span class="comment">// 将当前线程设置为独占所有者线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将state重置为0（释放锁）</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">            <span class="comment">// 如果state为0，表明没有线程获取到锁，那么就不存在释放锁这种说法，所以管程状态错误</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="comment">// 独占锁的释放，就是独占线程释放锁,所以独占所有者线程设为空</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 释放锁，表明之前锁已经被获取了，当前只会一个线程能够调用setState()，</span></span><br><span class="line"><span class="comment">             * 所以可以不用compareAndSetState(int,int）方法来进行原子操作的更新，可以直接调用setState()方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">            s.defaultReadObject();</span><br><span class="line">            setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The sync object does all the hard work. We just forward to it.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock接口的实现全部委托给sync</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.hasQueuedThreads();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS类中的共享锁示例"><a href="#AQS类中的共享锁示例" class="headerlink" title="AQS类中的共享锁示例"></a>AQS类中的共享锁示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BooleanLatch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isSignalled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isSignalled() ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> ignore)</span> </span>&#123;</span><br><span class="line">            setState(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSignalled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isSignalled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="AQS源码分析"><a href="#AQS源码分析" class="headerlink" title="AQS源码分析"></a>AQS源码分析</h1><h2 id="类继承关系"><a href="#类继承关系" class="headerlink" title="类继承关系"></a>类继承关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<h3 id="AbstractOwnableSynchronizer抽象类源码"><a href="#AbstractOwnableSynchronizer抽象类源码" class="headerlink" title="AbstractOwnableSynchronizer抽象类源码"></a>AbstractOwnableSynchronizer抽象类源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 版本序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3737899427754241961L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">AbstractOwnableSynchronizer</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 当前持有独占锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置独占线程</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setExclusiveOwnerThread</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        exclusiveOwnerThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取独占线程</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Thread <span class="title">getExclusiveOwnerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exclusiveOwnerThread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类中只有一个Thread类型的变量exclusiveOwnerThread及getter/setter方法，用来获取/设置独占线程，正如其名<code>Ownable</code> 一个线程可能专有的同步器。</p>
<p>这对getter/setter方法对于独占锁类型的并发工具特别有用。如ReentrantLock是一个可重入排他锁（排他锁又称独占锁），因此ReentrantLock类中经常用到这两个方法。</p>
<h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就是形成一个链表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代表当前锁的状态</span></span><br><span class="line">    <span class="comment">// = 0: 表示没有被占用</span></span><br><span class="line">    <span class="comment">// &gt; 0: 代表有线程持有当前锁，这个值也可能会大于1，是因为锁可用重入，每次重入都加1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="内部类：Node"><a href="#内部类：Node" class="headerlink" title="内部类：Node"></a>内部类：Node</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示在同步队列中当前节点的下一个等待节点的类型常量：共享型</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 表示在同步队列中当前节点的下一个等待节点的类型常量：独占型</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 一下四个常量可以作为waitStatus属性值。</span></span><br><span class="line">	  <span class="comment">// 线程的等待状态：表示线程已经被取消</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">  	<span class="comment">// 线程的等待状态：表示后继线程需要被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">  	<span class="comment">// 线程的等待状态：表示线程在Condition上</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">  	<span class="comment">// 表示下一个acquireShared需要无条件的传播</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">  	 * CANCELLED：一个节点由于超时或者中断需要在CLH队列中取消等待状态，被取消的节点不会再次等待（节点进入此状态后不再变化）</span></span><br><span class="line"><span class="comment">  	 * SIGNAL：当前节点的后继节点处于等待状态时，如果当前节点的同步状态被释放或者取消，必须唤起它的后继节点</span></span><br><span class="line"><span class="comment">  	 * CONDITION：当前节点在等待队列中，只有当节点的状态设置为0的时候该节点才会被转移到同步队列</span></span><br><span class="line"><span class="comment">  	 * PROPAGATE：下一次的共享模式同步状态的获取将会无条件的传播</span></span><br><span class="line"><span class="comment">  	 * </span></span><br><span class="line"><span class="comment">  	 * 该属性初始的时候为0</span></span><br><span class="line"><span class="comment">  	 * 使用CAS来修改节点的状态</span></span><br><span class="line"><span class="comment">  	 * AQS 在状态判断时，用waitStatus &gt; 0表示取消状态，waitStatus &lt;=0 表示有效状态</span></span><br><span class="line"><span class="comment">  	 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">/**</span></span><br><span class="line"><span class="comment">   	 * 当前节点的前驱节点</span></span><br><span class="line"><span class="comment">   	 * </span></span><br><span class="line"><span class="comment">   	 * 当前线程依赖它来检查waitStatus，在入队的时候才被分配，并且只有在出队的时候才被取消（为了GC），</span></span><br><span class="line"><span class="comment">   	 * 一个节点成为头节点仅仅是成功获取到锁的结果，一个被取消的线程永远也不会获取到锁，</span></span><br><span class="line"><span class="comment">   	 * 线程只取消自身，而不涉及其他节点</span></span><br><span class="line"><span class="comment">   	 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">/**</span></span><br><span class="line"><span class="comment">   	 * 当前节点的后继节点</span></span><br><span class="line"><span class="comment">   	 * </span></span><br><span class="line"><span class="comment">   	 * 当前线程释放的时候才被唤起,在入队时分配,在绕过被取消的前驱节点时调整,在出队列的时候取消(为了GC)</span></span><br><span class="line"><span class="comment">   	 * 如果一个节点的next为空,我们可以从尾部扫描它的prev,双重检查。</span></span><br><span class="line"><span class="comment">   	 * 被取消节点的next设置为指向节点本身而不是null,为了isOnSyncQueue更容易操作</span></span><br><span class="line"><span class="comment">   	 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点所对应的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个等待者</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 链接到下一个节点的等待条件，或特殊的值SHARED，因为条件队列只有在独占模式时才能被访问，</span></span><br><span class="line"><span class="comment">     * 所以我们只需要一个简单的连接队列在等待的时候保存节点，然后把他们转移到队列中重新获取</span></span><br><span class="line"><span class="comment">     * 因为条件只能是独占性的，我们通过使用特殊的值来表示共享模式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * nextWaiter在描述AQS同步队列的head、tail两个成员变量中不起太大的作用，只是表示共享型或独占型节点。</span></span><br><span class="line"><span class="comment">     * nextWaiter属性主要在描述Condition条件队列的firstWaiter和lastWaiter两个成员变量中起重要作用，表示下一个等待条件的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点是否在共享模式下等待</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 获取前驱节点，若节点为空，抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line"> 	  <span class="comment">// 用来建立初始化的head 或 SHARED的标记</span></span><br><span class="line">    Node() &#123;    </span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// addWaiter方法使用</span></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 设置条件时使用</span></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="内部类：ConditionObject"><a href="#内部类：ConditionObject" class="headerlink" title="内部类：ConditionObject"></a>内部类：ConditionObject</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">    <span class="comment">// condition队列的头节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">// condition队列的尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 添加新的waiter到wait队列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 保存尾节点</span></span><br><span class="line">        Node t = lastWaiter;</span><br><span class="line">      	<span class="comment">// 尾节点不为空，并且尾节点的状态不为CONDITION</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">          	<span class="comment">// 清除状态为CONDITION的节点</span></span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">          	<span class="comment">// 将最后一个节点重新赋值给t</span></span><br><span class="line">            t = lastWaiter;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 新建一个节点</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">      	<span class="comment">// 尾节点为空</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">          	<span class="comment">// 设置condition队列的头节点</span></span><br><span class="line">            firstWaiter = node;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 尾节点不为空</span></span><br><span class="line">          	<span class="comment">// 设置尾节点的nextWaiter域为node节点</span></span><br><span class="line">            t.nextWaiter = node;</span><br><span class="line">      	<span class="comment">// 更新condition队列的尾节点</span></span><br><span class="line">        lastWaiter = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          	<span class="comment">// 该节点的nextWaiter为空</span></span><br><span class="line">            <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">              	<span class="comment">// 设置尾节点为空</span></span><br><span class="line">                lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">          	<span class="comment">// 设置first节点的nextWaiter域</span></span><br><span class="line">            first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将节点从conditioin队列转移到sync队列失败并且condition队列中的头节点不为空，一直循环</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                 (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 唤醒first节点之后的所有节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// condition队列的头节点尾节点都设置为空</span></span><br><span class="line">        lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          	<span class="comment">// 获取first节点的nextWaiter域节点</span></span><br><span class="line">            Node next = first.nextWaiter;</span><br><span class="line">          	<span class="comment">// 设置first节点的nextWaiter域为空</span></span><br><span class="line">            first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">          	<span class="comment">// 将first节点从conditioin队列转移到sync队列</span></span><br><span class="line">            transferForSignal(first);</span><br><span class="line">            <span class="comment">// 重新设置next</span></span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 从condition队列中清除状态为CANCEL的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 保存condition队列头节点</span></span><br><span class="line">        Node t = firstWaiter;</span><br><span class="line">        Node trail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 获取下一个节点</span></span><br><span class="line">            Node next = t.nextWaiter;</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">              	<span class="comment">// 设置t节点的nextWaiter域为null</span></span><br><span class="line">                t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                  	<span class="comment">// 重新设置condition队列的头节点</span></span><br><span class="line">                    firstWaiter = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                  	<span class="comment">// 设置trail节点的nextWaiter域为next节点</span></span><br><span class="line">                    trail.nextWaiter = next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                  	<span class="comment">// 设置condition队列的尾节点</span></span><br><span class="line">                    lastWaiter = trail;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// t节点的状态为CONDITION状态</span></span><br><span class="line">              	<span class="comment">// 设置trail节点</span></span><br><span class="line">                trail = t;</span><br><span class="line">            t = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒一个等待线程。如果所有的线程都在等待此条件，则选择其中的一个唤醒。在从await返回之前，该线程必须重新获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 不被当前线程独占，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">      	<span class="comment">// 保存condition队列头节点</span></span><br><span class="line">        Node first = firstWaiter;</span><br><span class="line">      	<span class="comment">// 头节点不为空则唤醒一个等待线程</span></span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">            doSignal(first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唤醒所有等待线程。如果所有的线程都在等待此条件，则唤醒所有线程。在await返回之前，每个线程都必须重新获取锁。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 不被当前线程占用，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        Node first = firstWaiter;</span><br><span class="line">      	<span class="comment">// 头节点不为空则唤醒所有等待线程</span></span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">            doSignalAll(first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 等待，当前线程在接到信号之前一直处于等待状态，不响应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      	<span class="comment">// 添加一个节点到等待队列</span></span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">      	<span class="comment">// 获取释放的状态</span></span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">          	<span class="comment">// 阻塞抢钱线程</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">          	<span class="comment">// 当前线程被中断</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">              	<span class="comment">// 设置interrupted状态</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For interruptible waits, we need to track whether to throw</span></span><br><span class="line"><span class="comment">     * InterruptedException, if interrupted while blocked on</span></span><br><span class="line"><span class="comment">     * condition, versus reinterrupt current thread, if</span></span><br><span class="line"><span class="comment">     * interrupted while blocked waiting to re-acquire.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Mode meaning to reinterrupt on exit from wait */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REINTERRUPT =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** Mode meaning to throw InterruptedException on exit from wait */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THROW_IE    = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks for interrupt, returning THROW_IE if interrupted</span></span><br><span class="line"><span class="comment">     * before signalled, REINTERRUPT if after signalled, or</span></span><br><span class="line"><span class="comment">     * 0 if not interrupted.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">            <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Throws InterruptedException, reinterrupts current thread, or</span></span><br><span class="line"><span class="comment">     * does nothing, depending on mode.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 等待，当前线程在接到信号或被中断之前一直处于等待状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      	<span class="comment">// 当前线程被中断，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">      	<span class="comment">// 在wait队列上添加一个节点</span></span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">          	<span class="comment">// 阻塞当前线程</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">          	<span class="comment">// 检查节点等待时间的中断类型</span></span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                transferAfterCancelledWait(node);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        <span class="keyword">return</span> deadline - System.nanoTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待，当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> abstime = deadline.getTime();</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() &gt; abstime) &#123;</span><br><span class="line">                timedout = transferAfterCancelledWait(node);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkUntil(<span class="keyword">this</span>, abstime);</span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        <span class="keyword">return</span> !timedout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nanosTimeout = unit.toNanos(time);</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        Node node = addConditionWaiter();</span><br><span class="line">        <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                timedout = transferAfterCancelledWait(node);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">            interruptMode = REINTERRUPT;</span><br><span class="line">        <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">            unlinkCancelledWaiters();</span><br><span class="line">        <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">            reportInterruptAfterWait(interruptMode);</span><br><span class="line">        <span class="keyword">return</span> !timedout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  support for instrumentation</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if this condition was created by the given</span></span><br><span class="line"><span class="comment">     * synchronization object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if owned</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOwnedBy</span><span class="params">(AbstractQueuedSynchronizer sync)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync == AbstractQueuedSynchronizer.<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Queries whether any threads are waiting on this condition.</span></span><br><span class="line"><span class="comment">     * Implements &#123;<span class="doctag">@link</span> AbstractQueuedSynchronizer#hasWaiters(ConditionObject)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there are any waiting threads</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">     *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">for</span> (Node w = firstWaiter; w != <span class="keyword">null</span>; w = w.nextWaiter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w.waitStatus == Node.CONDITION)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an estimate of the number of threads waiting on</span></span><br><span class="line"><span class="comment">     * this condition.</span></span><br><span class="line"><span class="comment">     * Implements &#123;<span class="doctag">@link</span> AbstractQueuedSynchronizer#getWaitQueueLength(ConditionObject)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the estimated number of waiting threads</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">     *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWaitQueueLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node w = firstWaiter; w != <span class="keyword">null</span>; w = w.nextWaiter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w.waitStatus == Node.CONDITION)</span><br><span class="line">                ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a collection containing those threads that may be</span></span><br><span class="line"><span class="comment">     * waiting on this Condition.</span></span><br><span class="line"><span class="comment">     * Implements &#123;<span class="doctag">@link</span> AbstractQueuedSynchronizer#getWaitingThreads(ConditionObject)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the collection of threads</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">     *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;Thread&gt; <span class="title">getWaitingThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        ArrayList&lt;Thread&gt; list = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Node w = firstWaiter; w != <span class="keyword">null</span>; w = w.nextWaiter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w.waitStatus == Node.CONDITION) &#123;</span><br><span class="line">                Thread t = w.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    list.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="独占式：acquire"><a href="#独占式：acquire" class="headerlink" title="独占式：acquire"></a>独占式：acquire</h1><blockquote>
<p>逐行分析看着比较吃力，可以先看看最后的总结：AQS独占式获取锁逻辑：详细版</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以独占模式获取（资源），忽略中断，即线程在aquire过程中，中断此线程是无效的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 调用tryAcquire方法获取同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">// 调用addWaiter方法把线程封装成一个Node节点添加到同步队列的尾部，</span></span><br><span class="line">        <span class="comment">// 然后调用acquireQueued方法使节点以自旋的方式获取同步状态</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：通过调用acquire获取同步状态，该方法忽略中断，线程获取同步状态失败后，进入同步队列，在对其进行中断操作后，线程不会从同步队列移除。</p>
<p>流程：</p>
<ul>
<li>首先调用 <code>tryAcquire</code> 方法获取同步状态，AQS并没有实现这个方法，具体的实现由它的继承类进行重写，如：ReentrantLock的Sync类。</li>
<li>如果获取同步状态成功直接返回true，如果获取失败执行下面的步骤。</li>
<li>调用addWaiter方法把线程封装成一个独占式的Node节点添加到同步队列的尾部，然后调用acquireQueued方法使节点以自旋的方式获取同步状态，如果获取同步状态失败，要挂起线程（被挂起的线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现），最后，线程如果在获取同步状态中和同步队列中被中断过，要进行自我中断。</li>
</ul>
<h2 id="添加新的等待节点：addwaiter"><a href="#添加新的等待节点：addwaiter" class="headerlink" title="添加新的等待节点：addwaiter"></a>添加新的等待节点：addwaiter</h2><p>主要通过调用<code>compareAndSetTail(Node node)</code> 来确保正确安全的设置尾节点，避免了非线程安全状态下添加新节点时节点先后顺序混乱的情况，如果一次CAS设置尾节点失败，则直接进入<code>enq(final Node)</code> 方法通过自旋的CAS操作，直到将节点设置为尾节点成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把Node节点添加到同步队列的尾部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 以独占模式把当前线程封装成一个Node节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 尝试快速入队</span></span><br><span class="line">    Node pred = tail; <span class="comment">// 当前队列的尾节点赋给pred</span></span><br><span class="line">  	<span class="comment">// 尾节点不为空</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">      	<span class="comment">// 把旧的尾节点作为新节点的前驱节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">      	<span class="comment">// 利用CAS把node作为尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">          	<span class="comment">// 将新的node节点作为旧的尾节点的后继节点。 pred &lt;-&gt; node</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">          	<span class="comment">// 直接返回node</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 尾节点为空 或者 利用CAS把node设置为尾节点失败</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：简单来说就是把当前线程按照mode模式（独占/共享）封装成一个node节点，然后把node节点添加到队列尾部，但是当入队失败或者尾节点为空，就需要调用enq方法自旋了。</p>
<p>这里的操作非常经典，将入队操作提前尝试快速入队，如果失败才去执行自旋。</p>
<h3 id="自旋添加尾节点：enq"><a href="#自旋添加尾节点：enq" class="headerlink" title="自旋添加尾节点：enq"></a>自旋添加尾节点：enq</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 采用自旋方式把node插入到队列中  t &lt;-&gt; node : t.next = node; node.prev = t;</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">      	<span class="comment">// 如果尾节点为空，说明队列为空，必须初始化</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">          	<span class="comment">// 新建一个节点利用CAS设置为头节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">              	<span class="comment">// tail 和 head都指向这个新节点</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">          	<span class="comment">// 把旧的尾节点设为node的前驱节点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">          	<span class="comment">// 利用CAS把node节点设为尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">              	<span class="comment">// 将新的node节点作为旧的尾节点的后继节点。 pred &lt;-&gt; node</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>enq</code> 方法采用了非常经典的自旋操作，只有通过CAS把node设为尾节点后，当前线程才能退出该方法，否则的话，当前线程不断尝试，直到能把节点添加到队列中为止，这样就把并行添加变成了串行添加。</p>
<h2 id="获取同步状态：acquireQueued"><a href="#获取同步状态：acquireQueued" class="headerlink" title="获取同步状态：acquireQueued"></a>获取同步状态：acquireQueued</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过自旋方式获取同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">// 默认线程没有被中断过</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          	<span class="comment">// 获取该节点前驱节点p 内部类Node中的方法</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">          	<span class="comment">// 如果p是头节点并且能获取到同步状态(tryAcquire由子类实现)</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">              	<span class="comment">// 把当前节点设置为头节点</span></span><br><span class="line">                setHead(node); <span class="comment">// head = node; node.thread = null; node.prev = null;</span></span><br><span class="line">              	<span class="comment">// 把p的next设为null，便于GC</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">              	<span class="comment">// 标志位，表示成功获取同步状态，默认是true，表示失败</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">              	<span class="comment">// 返回该线程在获取到同步状态的过程中有没有被中断过</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 判断是否挂起当前线程  具体源码参考3.2.1及3.2.2</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 线程被中断过</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      	<span class="comment">// 如果failed为true，直接移除当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先获取当前节点的前驱节点，如果前驱节点是头节点，有两种情况</p>
<ol>
<li>默认空的头节点，说明此时是同步队列中的第一个线程去尝试获取同步状态。</li>
<li>获取到同步状态的节点，然后再一次调用子类重写的tryAcquire方法去获取同步状态，如果成功获取同步状态，则把当前节点设为头节点。</li>
</ol>
<p>如果当前节点的前驱节点不是头节点或者没有获取到同步状态的话，就要调用shouldParkAfterFailedAcquire方法挂起当前线程。</p>
<p>注：为什么只有前驱节点为头节点才能尝试获取同步状态？</p>
<ul>
<li>首先队列这种数据结构要保证FIFO的基本原则。</li>
<li>其次头节点是当前获取到同步状态的节点，只有在头节点释放同步状态，才能通知后继节点可以进入同步状态。</li>
</ul>
<h3 id="检查同步状态失败是否需要阻塞线程：shouldParkAfterFailedAcquire"><a href="#检查同步状态失败是否需要阻塞线程：shouldParkAfterFailedAcquire" class="headerlink" title="检查同步状态失败是否需要阻塞线程：shouldParkAfterFailedAcquire"></a>检查同步状态失败是否需要阻塞线程：shouldParkAfterFailedAcquire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果线程获取同步状态失败就要检查它的节点status，要保证prev = node.prev</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 获取当前节点的前驱节点的waitStatus</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果前驱节点的ws = SIGNAL，表示前驱节点释放后会唤起当前线程，</span></span><br><span class="line"><span class="comment">         * 可以安全的挂起当前线程，如果前驱状态不是SIGNAL，node还要参加同步状态的争夺</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 能够挂起当前线程直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; <span class="comment">// ws == CANCELLED</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 前驱节点的ws &gt; 0，说明ws = CANCELLED，表示前驱线程被取消，</span></span><br><span class="line"><span class="comment">         * 继续往前遍历，直到找到一个有效节点（前驱节点的 ws &lt;= 0）作为node的前驱节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果前驱正常，那就把前驱的状态设置成SIGNAL。CAS可能失败，pred可能刚释放锁</span></span><br><span class="line"><span class="comment">         * SIGNAL表示前驱节点释放同步状态会唤醒当前节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：这段代码用来检测是否挂起当前线程，分三种情况</p>
<ul>
<li>前驱节点的<code>ws = SINGAL</code> ：表示前驱节点释放同步状态的时候会唤醒当前节点，可以安全挂起当前线程。</li>
<li> 前驱节点被取消：那就从前驱节点继续往前遍历，直到找到第一个ws &lt;= 0的节点。</li>
<li> 前驱节点的ws = 0：表示前驱节点获取到同步状态，当前线程不能挂起，因该尝试去获取同步状态，前驱节点的同步状态的释放正好可以让当前节点进行获取，所以使用CAS把前驱节点的ws设为SINGAL，另外如果ws = PROPAGATE，说明以共享模式进行传播，也需要使用CAS把ws设置为SINGAL。</li>
</ul>
<h3 id="挂起当前线程并检查当前线程是否被中断：parkAndCheckInterrupt"><a href="#挂起当前线程并检查当前线程是否被中断：parkAndCheckInterrupt" class="headerlink" title="挂起当前线程并检查当前线程是否被中断：parkAndCheckInterrupt"></a>挂起当前线程并检查当前线程是否被中断：parkAndCheckInterrupt</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 挂起当前线程并判断线程是否被中断过</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 调用LockSupport.park方法挂起当前线程，返回该线程是否被中断过，如果被中断过，直接设置interrupted = true</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="从同步队列中移除无效的节点：cancelAcquire"><a href="#从同步队列中移除无效的节点：cancelAcquire" class="headerlink" title="从同步队列中移除无效的节点：cancelAcquire"></a>从同步队列中移除无效的节点：cancelAcquire</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前节点不存在的话直接忽略</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 把当前节点的线程设置为null</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前节点的前驱节点pred</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">  	<span class="comment">// 如果pred的ws &gt; 0，直接跳过pred继续往前遍历，直到pred的ws &lt;= 0</span></span><br><span class="line">    <span class="comment">// 找到第一个没有被取消的节点（有效节点）</span></span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存pred的原始后继节点，在CAS更新pre的后继节点将会用到predNext</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把node节点的ws设为CANCELLED</span></span><br><span class="line">    <span class="comment">// 在此后其他线程见到此节点的状态，将会路过此节点。在此之前其他线程不受影响</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果node是尾节点，则尝试将与node最近的有效节点pred设置为新的尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">      	<span class="comment">// 上面的CAS成功，pred就是最新的尾节点，尾节点的后继节点为null</span></span><br><span class="line">        <span class="comment">// 因此CAS将pred的后继节点设为null,而之前的 “while (pred.waitStatus &gt; 0)”循环已经将其前驱节点更新了。</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">      	<span class="comment">// pred不是头节点 &amp;&amp; pred.wx = SINGAL &amp;&amp; pred的线程不为空</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 利用CAS把node的next设为pred的next节点</span></span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">// node是头节点，唤起它的后继节点</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：分为三种情况进行考虑</p>
<ul>
<li>node本身就是尾节点,直接把node的prev设置为尾节点.</li>
<li>node的prev不是头节点,直接把pred和node的next进行连接.</li>
<li>node的prev是头节点,使用unparkSuccessor唤醒后继节点.</li>
</ul>
<h4 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果node存在唤醒它的后继节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取node的ws，如果ws &lt; 0，使用CAS把node的ws设为0，表示释放同步状态</span></span><br><span class="line">  	<span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 获取node的后续节点s，如果next是null或者被取消了，就从tail开始向上查找</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">      	<span class="comment">// 从同步队列的尾部开始遍历直到找到距node最近的满足 ws &lt;= 0的节点t，把t赋给s</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 如果s不为null &amp;&amp; s的ws &lt;= 0，直接唤醒s的线程</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="selfInterrupt"><a href="#selfInterrupt" class="headerlink" title="selfInterrupt"></a>selfInterrupt</h2><p>如果执行完acquireQueued方法返回线程被中断过,那线程最后要进行自我中断一下.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="其他获取同步状态的方法"><a href="#其他获取同步状态的方法" class="headerlink" title="其他获取同步状态的方法"></a>其他获取同步状态的方法</h2><h3 id="响应式中断获取同步状态acquireInterruptibly"><a href="#响应式中断获取同步状态acquireInterruptibly" class="headerlink" title="响应式中断获取同步状态acquireInterruptibly"></a>响应式中断获取同步状态acquireInterruptibly</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前线程被中断后，直接抛出异常，否则的话，再次调用tryAcquire方法获取同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="doAcquireInterruptibly"><a href="#doAcquireInterruptibly" class="headerlink" title="doAcquireInterruptibly"></a>doAcquireInterruptibly</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以独占模式获取同步状态，线程被中断直接抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="指定时间内获取同步状态-tryAcquireNanos"><a href="#指定时间内获取同步状态-tryAcquireNanos" class="headerlink" title="指定时间内获取同步状态: tryAcquireNanos"></a>指定时间内获取同步状态: tryAcquireNanos</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以独占模式获取同步状态，线程被中断，直接抛出异常，如果再指定时间内没有获取到同步状态，</span></span><br><span class="line"><span class="comment">// 直接返回false，表示获取同步状态失败</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="doAcquireNanos"><a href="#doAcquireNanos" class="headerlink" title="doAcquireNanos"></a>doAcquireNanos</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  	<span class="comment">// 如果指定时间nanosTimeOut &lt;= 0，表示已经超时，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  	<span class="comment">// </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="释放同步状态的方法：release"><a href="#释放同步状态的方法：release" class="headerlink" title="释放同步状态的方法：release"></a>释放同步状态的方法：release</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 尝试释放同步状态(同步组件需要重写tryRelease)</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">      	<span class="comment">// 所有的节点在将自己挂起之前，都会将前置节点设置成 SIGNAL，希望前置节点释放的时候，唤醒自己。</span></span><br><span class="line">        <span class="comment">// 如果前置节点是 0 ，说明前置节点已经释放过了。不能重复释放了，后面将会看到释放后会将 ws 修改成0</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">          	<span class="comment">// 唤醒后继节点</span></span><br><span class="line">						unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="共享式"><a href="#共享式" class="headerlink" title="共享式"></a>共享式</h1><p>独占式和共享式的最大不同就是在同一时刻能否有多个线程获取同步状态，通过调用acquireShared方法获取同步状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tryAcquireShared是留给子类去重写的,如果tryAcquireShared方法返回值&lt;0,说明获取同步状态失败</span></span><br><span class="line">  	<span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="doAcquireShared"><a href="#doAcquireShared" class="headerlink" title="doAcquireShared"></a>doAcquireShared</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以共享非中断获取同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  	<span class="comment">// 传播唤醒的动作</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setHeadAndPropagate"><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 保存当前的头节点</span></span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">  	<span class="comment">// 把当前节点设为头节点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">   	<span class="comment">// 这里有三种情况执行唤醒操作：</span></span><br><span class="line">  	<span class="comment">// 1.propagate &gt; 0,代表后继节点需要被唤醒</span></span><br><span class="line">  	<span class="comment">// 2.h节点的ws &lt; 0 或者 h = null</span></span><br><span class="line">    <span class="comment">// 3.新的头节点为空 或者 新的头节点的ws &lt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      	<span class="comment">// 找到当前节点的后继节点s</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">      	<span class="comment">// s=null 或者 s是共享模式,调用doReleaseShared方法唤醒后继线程</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 注意这里的头节点已经是上面新设定的头节点了，从这里可以看出，如果propagate = 0，</span></span><br><span class="line"><span class="comment">     * 不会进入doReleaseShared方法，那就由共享式变成了独占式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 死循环，直到满足h = head才退出</span></span><br><span class="line">        Node h = head;</span><br><span class="line">      	<span class="comment">// 前提条件：当前的头节点不为null &amp;&amp; h不是尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">          	<span class="comment">// 如果当前头节点为SINGAL状态。</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">              	<span class="comment">// 利用CAS把h的ws设为0，以后就不会再次唤醒后继节点了</span></span><br><span class="line">              	<span class="comment">// 这一步是为了解决并发问题，保证只unpark一次。</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">              	<span class="comment">// 唤醒头节点的后继节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 如果h的ws=0，就把h的ws设为PROPAGATE，表示可以向后传播唤醒</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 如果头节点没有发生变化，表示设置成功，可以退出循环</span></span><br><span class="line">      	<span class="comment">// 如果头节点发生了变化，可能被唤醒的其他节点重新设置了头节点，要进行重试，保证可以传播唤醒信号</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><blockquote>
<p>如果只是为了应付面试可以只看下面的内容。</p>
</blockquote>
<h2 id="AQS类的核心概念"><a href="#AQS类的核心概念" class="headerlink" title="AQS类的核心概念"></a>AQS类的核心概念</h2><ul>
<li>AQS主要实现了独占式和共享式两种，独占式的同步状态在0与1之间切换，同时只能有一个线程获取锁进行操作，而共享式同一时刻可以有多个线程获取锁。</li>
<li>AQS会把所有的请求线程构成一个CLH队列，当一个线程执行完毕(lock.unlock)时会激活自己的后继节点，但正在执行的线程并不在队列中，而那些等待执行的线程全部处于阻塞状态。</li>
<li>AQS采用Node类型的双向链表来确定资源获取线程的排队工作，其中头节点是获取同步状态成功的节点，头节点的线程在释放同步状态时，将会唤醒它的后继节点，而后继节点将会在获取同步状态成功时将自己设置为头节点。而没有成功获取同步状态的线程会成为节点加入该队列的尾部，为了线程安全采用了CAS原子方法更新尾部插入节点。</li>
</ul>
<h2 id="AQS类最关键的几个变量："><a href="#AQS类最关键的几个变量：" class="headerlink" title="AQS类最关键的几个变量："></a>AQS类最关键的几个变量：</h2><ul>
<li><code>AQS.head</code> : 同步队列头节点，表示获取同步状态成功节点。</li>
<li><code>AQS.tail</code> : 阻塞的尾节点，每个新进来的节点，都插入到最后，形成一个链表。</li>
<li><code>AQS.state</code> : 表示当前锁的状态，0表示没有被占用，大于0表示有线程持有当前锁，当大于1的时候表示锁重入。</li>
<li><code>Node.waitStatus</code> : 表示节点状态，分为CANCELLED（被取消的节点）、SIGNAL（前驱节点正在占用锁）、CONDITION（）、PROPAGATE（）</li>
<li><code>Node.nextWaiter</code> : nextWaiter在描述同步队列的head和tail两个成员变量中只是表示共享型或独占型节点。其主要是在描述Condition条件队列的firstWaiter和lastWaiter两个成员变量中起比较重要的作用，表示下一个等待条件的节点。</li>
<li><code>ConditionObject.firstWaiter</code> : condition队列的头节点。</li>
<li><code>ConditionObject.lastWaiter</code> : condition队列的尾节点。</li>
</ul>
<h2 id="AQS独占式获取锁逻辑：简单版"><a href="#AQS独占式获取锁逻辑：简单版" class="headerlink" title="AQS独占式获取锁逻辑：简单版"></a>AQS独占式获取锁逻辑：简单版</h2><p>1、首先调用 <code>tryAcquire</code> 方法获取同步状态，AQS并没有实现这个方法，具体的实现由它的子类实现，如：ReentrantLock的Sync类。如果获取同步状态失败执行下面的步骤。</p>
<p>2、调用addWaiter方法把线程封装成一个独占式的Node节点添加到同步队列的尾部。</p>
<p>3、然后调用acquireQueued方法使节点以自旋的方式获取同步状态，如果获取同步状态失败，要挂起线程（被挂起线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现）。</p>
<p>4、最后，线程如果在获取同步状态中和同步队列中被中断过，还要进行一次自我中断。</p>
<h2 id="AQS独占式获取锁逻辑：详细版"><a href="#AQS独占式获取锁逻辑：详细版" class="headerlink" title="AQS独占式获取锁逻辑：详细版"></a>AQS独占式获取锁逻辑：详细版</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">acquire(<span class="keyword">int</span> arg)</span><br><span class="line">  <span class="comment">// 调用由子类实现的tryAcquire方法,如果返回true表示获取同步状态成功，那么后面操作将不再继续</span></span><br><span class="line">	tryAcquire(<span class="keyword">int</span>) </span><br><span class="line">	<span class="comment">// 首先调用addWaiter方法把线程封装成一个Node节点，通过compareAndSetTail将节点添加到同步队列的尾部</span></span><br><span class="line">  <span class="comment">// 如果添加失败，或者当前尾节点为空的情况下调用enq(final Node node)方法自旋添加</span></span><br><span class="line">  addWaiter(Node.EXCLUSIVE)</span><br><span class="line">  	<span class="comment">// 当addWaiter中尝试快速入队失败的情况下需要调用enq自旋添加尾节点</span></span><br><span class="line">  	<span class="comment">// 自旋添加到尾节点，首先会判断尾节点是否为空，如果为空先初始化，通过CAS设置head</span></span><br><span class="line">  	<span class="comment">// 尾节点不为空后则自旋的通过CAS设置当前节点为尾节点</span></span><br><span class="line">  	enq(<span class="keyword">final</span> Node node)</span><br><span class="line">  <span class="comment">// 把当前线程封装的节点添加到链表尾部后调用acquireQueued方法使节点以自旋的方式获取同步状态。</span></span><br><span class="line">	<span class="comment">// 主要操作就是获取当前节点的前驱节点，判断其是不是头节点</span></span><br><span class="line">  <span class="comment">// 如果前驱节点是头节点，再判断现在是否能获取到同步状态，如果能获取到则把自己设置为头节点，并且修改标志位</span></span><br><span class="line">  <span class="comment">// 如果不是头节点，或者自身获取同步状态失败的情况下需要调用shouldParkAfterFailedAcquire方法判断是否需要挂起线程</span></span><br><span class="line">  acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">  	<span class="comment">// 判断前驱节点(pred)的waitStatus状态</span></span><br><span class="line">  	<span class="comment">// 1.如果状态为 SIGNAL 可以放心的调用parkAndCheckInterrupt方法挂起当前线程</span></span><br><span class="line">  	<span class="comment">// 2.如果状态&gt; 0 表示前驱节点状态为CANCELLED被取消，则循环向前遍历直到找到一个有效前驱节点</span></span><br><span class="line">  	<span class="comment">// 3.其他节点状态下把当前的前驱节点状态设置为SIGNAL</span></span><br><span class="line">  	shouldParkAfterFailedAcquire(Node pred, Node node)</span><br><span class="line">      <span class="comment">// 挂起当前线程并判断线程是否被中断过</span></span><br><span class="line">  		<span class="comment">// 如果当前线程被中断过，当方法acquireQueued结束的时候会调用cancelAcquire移除当前节点</span></span><br><span class="line">      parkAndCheckInterrupt()</span><br><span class="line">  	<span class="comment">// 从同步队列中移除无效节点</span></span><br><span class="line">  	<span class="comment">// 设置当前节点线程为null，再循环向前遍历，直到找到一个有效的前驱节点，并设置当前节点状态为CANCELLED已取消</span></span><br><span class="line">  	<span class="comment">// 1.如果node是尾节点的情况，尝试将node最近的有效节点pred设置为新的尾节点，成功则再通过CAS将pred(新的尾节点)的后继节点设置为null</span></span><br><span class="line">  	<span class="comment">// 2.如果pred不是头节点，则判断pred的waitStatus状态是否为SIGNAL，如果不是通过CAS将waitStatus设置为SIGNAL，成功的情况下把pred和node.next连接</span></span><br><span class="line">  	<span class="comment">// 3.如果pred是头节点的情况调用unparkSuccessor方法唤醒后继节点</span></span><br><span class="line">  	cancelAcquire(Node node)</span><br><span class="line">  		<span class="comment">// 唤醒后继节点</span></span><br><span class="line">  		<span class="comment">// 如果当前节点的waitStatus &lt; 0 则使用CAS把ws设置为0，表示释放同步状态</span></span><br><span class="line">  		<span class="comment">// 再获取当前节点的后继节点，如果为null或者被取消了则从同步队列的尾部往前查找</span></span><br><span class="line">  		<span class="comment">// 直到找到距离node最近的未取消的节点，如果找到了则唤醒它</span></span><br><span class="line">  		unparkSuccessor(Node node)</span><br><span class="line">  	</span><br><span class="line">	selfInterrupt() <span class="comment">// 如果在执行acquireQueued方法中线程被中断过，需要进行自我中断一下</span></span><br><span class="line">	</span><br></pre></td></tr></table></figure>



<h2 id="AQS独占式释放锁逻辑"><a href="#AQS独占式释放锁逻辑" class="headerlink" title="AQS独占式释放锁逻辑"></a>AQS独占式释放锁逻辑</h2><p>调用tryRelease尝试释放同步状态，然后再唤醒头节点的后继节点线程（主要是将node节点的waitStatus设置为初始值0，并唤醒可用的后继节点）。</p>
<h2 id="AQS共享式获取锁逻辑"><a href="#AQS共享式获取锁逻辑" class="headerlink" title="AQS共享式获取锁逻辑"></a>AQS共享式获取锁逻辑</h2><h2 id="AQS共享式释放锁逻辑"><a href="#AQS共享式释放锁逻辑" class="headerlink" title="AQS共享式释放锁逻辑"></a>AQS共享式释放锁逻辑</h2>
      

      
        <div class="page-reward">
          <a href="javascript:;" class="page-reward-btn tooltip-top">
            <div class="tooltip tooltip-east">
            <span class="tooltip-item">
              赏
            </span>
            <span class="tooltip-content">
              <span class="tooltip-text">
                <span class="tooltip-inner">
                  <p class="reward-p"><i class="icon icon-quo-left"></i>谢谢你请我吃糖果<i class="icon icon-quo-right"></i></p>
                  <div class="reward-box">
                    
                    <div class="reward-box-item">
                      <img class="reward-img" src="/img/zfbskm.png">
                      <span class="reward-type">支付宝</span>
                    </div>
                    
                    
                    <div class="reward-box-item">
                      <img class="reward-img" src="/img/wxskm.png">
                      <span class="reward-type">微信</span>
                    </div>
                    
                  </div>
                </span>
              </span>
            </span>
          </div>
          </a>
        </div>
      
    </div>
    <div class="article-info article-info-index">
      
      
        
<div class="share-wrap">
        <div class="share-icons">
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="icon icon-weibo"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="icon icon-weixin"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="icon icon-qq"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="icon icon-douban"></i>
          </a>
          <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a>
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="icon icon-facebook"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="icon icon-twitter"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="icon icon-google"></i>
          </a>
        </div>
      </div>

<div class="page-modal wx-share js-wx-box">
    <a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//pan.baidu.com/share/qrcode?url=http://www.ityizhan.net/simple/101030/" alt="微信分享二维码">
    </div>
</div>

<div class="mask js-mask"></div>
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">源码分析</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">JUC</a>
        		</li>
      		
		</ul>
	</div>

      
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/JUC//" class="article-tag-list-link color4">JUC</a>
        		</li>
      		
		</ul>
	</div>


      


      <div class="clearfix"></div>
    </div>
  </div>
</article>

  <div class="article-card">
	<div class="article-card-img">
		<img src="/img/wxgzh.jpg" alt="程序驿站">
	</div>
	<div class="article-card-content">
		<p><span>本文标题: </span><a href="http://www.ityizhan.net/simple/101030/" title="03.JUC核心篇：AQS(AbstractQueueSynchronizer)" target="_blank">03.JUC核心篇：AQS(AbstractQueueSynchronizer)</a></p>
	    <p><span>文章作者: </span><a href="/" target="_blank">程序驿站</a></p>
	    <p><span>发布时间: </span>2021-04-02</p>
	    <p><span>最后更新: </span>2021-05-24</p>
	    <p><span>版权声明: </span>本文为<a href="http://www.ityizhan.net">「程序驿站」</a>的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
	    <p><span>本文链接: </span><a href="http://www.ityizhan.net/simple/101030/" title="03.JUC核心篇：AQS(AbstractQueueSynchronizer)" target="_blank">http://www.ityizhan.net/simple/101030/</a></p>
	</div>
</div>
  
<nav id="article-nav">
  
    <a href="/code/101020/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          02.JUC核心篇：LockSupport
        
      </div>
    </a>
  
  
    <a href="/simple/101040/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">04.JUC核心篇：CAS(Compare and Swap)</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>


<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
        <script async src="/js/demo.js"></script>
        <div class="toc-container tooltip-left">
            <i class="icon-font icon-category1 menu_button"></i>
            <i class="icon-font icon-category2 menu_button"></i>
            <a class="icon-font icon-category3" href="javascript:window.history.back();"></a>
            <div class="tooltip tooltip-east">
                <span class="tooltip-item">
                </span>
                <span class="tooltip-content" id="content-menu">
                    <div class="toc-article">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#AQS%EF%BC%88AbstractQueueSynchronizer%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">AQS（AbstractQueueSynchronizer）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8AQS%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">同步容器AQS的基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">使用技巧</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E5%8F%AF%E9%87%8D%E5%86%99%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">AQS可重写的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E4%B8%AD%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">AQS中的模板方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.</span> <span class="toc-text">源码示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%8E%92%E4%BB%96%E9%94%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">AQS类中的排他锁示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%85%B1%E4%BA%AB%E9%94%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">AQS类中的共享锁示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">AQS源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.</span> <span class="toc-text">类继承关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractOwnableSynchronizer%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%BA%90%E7%A0%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">AbstractOwnableSynchronizer抽象类源码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">2.2.</span> <span class="toc-text">类属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9ANode"><span class="toc-number">2.3.</span> <span class="toc-text">内部类：Node</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%9AConditionObject"><span class="toc-number">2.4.</span> <span class="toc-text">内部类：ConditionObject</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E5%BC%8F%EF%BC%9Aacquire"><span class="toc-number">3.</span> <span class="toc-text">独占式：acquire</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84%E7%AD%89%E5%BE%85%E8%8A%82%E7%82%B9%EF%BC%9Aaddwaiter"><span class="toc-number">3.1.</span> <span class="toc-text">添加新的等待节点：addwaiter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E6%B7%BB%E5%8A%A0%E5%B0%BE%E8%8A%82%E7%82%B9%EF%BC%9Aenq"><span class="toc-number">3.1.1.</span> <span class="toc-text">自旋添加尾节点：enq</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%EF%BC%9AacquireQueued"><span class="toc-number">3.2.</span> <span class="toc-text">获取同步状态：acquireQueued</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E5%A4%B1%E8%B4%A5%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E9%98%BB%E5%A1%9E%E7%BA%BF%E7%A8%8B%EF%BC%9AshouldParkAfterFailedAcquire"><span class="toc-number">3.2.1.</span> <span class="toc-text">检查同步状态失败是否需要阻塞线程：shouldParkAfterFailedAcquire</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E5%B9%B6%E6%A3%80%E6%9F%A5%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E8%A2%AB%E4%B8%AD%E6%96%AD%EF%BC%9AparkAndCheckInterrupt"><span class="toc-number">3.2.2.</span> <span class="toc-text">挂起当前线程并检查当前线程是否被中断：parkAndCheckInterrupt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E4%B8%AD%E7%A7%BB%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%9AcancelAcquire"><span class="toc-number">3.2.3.</span> <span class="toc-text">从同步队列中移除无效的节点：cancelAcquire</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#unparkSuccessor"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">unparkSuccessor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#selfInterrupt"><span class="toc-number">3.3.</span> <span class="toc-text">selfInterrupt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%8E%B7%E5%8F%96%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">其他获取同步状态的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E4%B8%AD%E6%96%AD%E8%8E%B7%E5%8F%96%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81acquireInterruptibly"><span class="toc-number">3.4.1.</span> <span class="toc-text">响应式中断获取同步状态acquireInterruptibly</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#doAcquireInterruptibly"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">doAcquireInterruptibly</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E5%86%85%E8%8E%B7%E5%8F%96%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81-tryAcquireNanos"><span class="toc-number">3.4.2.</span> <span class="toc-text">指定时间内获取同步状态: tryAcquireNanos</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#doAcquireNanos"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">doAcquireNanos</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9Arelease"><span class="toc-number">3.5.</span> <span class="toc-text">释放同步状态的方法：release</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">共享式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#doAcquireShared"><span class="toc-number">4.1.</span> <span class="toc-text">doAcquireShared</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setHeadAndPropagate"><span class="toc-number">4.1.1.</span> <span class="toc-text">setHeadAndPropagate</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#doReleaseShared"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">doReleaseShared</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">总结：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS%E7%B1%BB%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">AQS类的核心概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS%E7%B1%BB%E6%9C%80%E5%85%B3%E9%94%AE%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="toc-number">5.2.</span> <span class="toc-text">AQS类最关键的几个变量：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS%E7%8B%AC%E5%8D%A0%E5%BC%8F%E8%8E%B7%E5%8F%96%E9%94%81%E9%80%BB%E8%BE%91%EF%BC%9A%E7%AE%80%E5%8D%95%E7%89%88"><span class="toc-number">5.3.</span> <span class="toc-text">AQS独占式获取锁逻辑：简单版</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS%E7%8B%AC%E5%8D%A0%E5%BC%8F%E8%8E%B7%E5%8F%96%E9%94%81%E9%80%BB%E8%BE%91%EF%BC%9A%E8%AF%A6%E7%BB%86%E7%89%88"><span class="toc-number">5.4.</span> <span class="toc-text">AQS独占式获取锁逻辑：详细版</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS%E7%8B%AC%E5%8D%A0%E5%BC%8F%E9%87%8A%E6%94%BE%E9%94%81%E9%80%BB%E8%BE%91"><span class="toc-number">5.5.</span> <span class="toc-text">AQS独占式释放锁逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS%E5%85%B1%E4%BA%AB%E5%BC%8F%E8%8E%B7%E5%8F%96%E9%94%81%E9%80%BB%E8%BE%91"><span class="toc-number">5.6.</span> <span class="toc-text">AQS共享式获取锁逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS%E5%85%B1%E4%BA%AB%E5%BC%8F%E9%87%8A%E6%94%BE%E9%94%81%E9%80%BB%E8%BE%91"><span class="toc-number">5.7.</span> <span class="toc-text">AQS共享式释放锁逻辑</span></a></li></ol></li></ol>
                    </div>
                </span>
            </div>
        </div>
        
    </div>
</aside>



  
  
  

  

  

  


   


<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2021 程序驿站 <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn">浙ICP备20022402号-2</a>
    	</div>
      	
    </div>
  </div>
</footer>

    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script async src="/js/yilia-script.js"></script>
<script async src="/./main.0cf68a.js"></script>
<script async src="/./slider.e37972.js"></script>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 100%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">源码分析</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">JUC</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">tools</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">IntelliJ IDEA</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">Maven</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    

    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>